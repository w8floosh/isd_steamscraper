import { auth } from 'src/boot/axios';
import {
  SessionCookieVerifierResponse,
  SessionResponse,
  TokenResponse,
  UserCredentials,
} from './types';
import { ref } from 'vue';

function getRandomCodeVerifier() {
  return Array.from(crypto.getRandomValues.bind(crypto)(new Uint8Array(24)))
    .map((byte) => byte.toString(16).padStart(2, '0'))
    .join('');
}

export const useAuthenticationService = () => {
  const auth_url = process.env.AUTH_SERVER_URL || auth.defaults.baseURL;
  const login = async (credentials: UserCredentials, redirect_uri: string) => {
    const state = getRandomCodeVerifier();
    const authCode = await auth.post(auth_url + '/auth/login', credentials, {
      params: {
        response_type: 'code',
        client_id:
          process.env.NODE_ENV === 'production'
            ? 'steamscraper_client'
            : 'debug',
        redirect_uri,
        state,
        code_challenge: state,
        code_challenge_method: 'plain',
      },
      withCredentials: true,
    });
    return {
      authCode: authCode.data.code,
      clientState: authCode.data.state,
      user: authCode.data.user,
    };
  };

  const logout = async () => {
    await auth.patch(auth_url + '/auth/logout', null, {
      withCredentials: true,
    });
  };

  const resume = async (): Promise<SessionResponse | null> => {
    const session = await auth.get<SessionCookieVerifierResponse>(
      auth_url + '/auth/verify',
      {
        withCredentials: true,
      }
    );
    const { refresh, ...sessionData } = session.data;
    if (!refresh)
      return {
        user: session.data.user,
        token: session.data.token,
      };

    const refreshedTokens = await auth.post<TokenResponse>(
      auth_url + '/oauth/token',
      {
        grant_type: 'refresh_token',
        refresh_token: sessionData.token,
        client_id:
          process.env.NODE_ENV === 'production'
            ? 'steamscraper_client'
            : 'debug',
      },
      { withCredentials: true }
    );

    return {
      user: session.data.user,
      token: refreshedTokens.data.access_token,
    };
  };

  const register = async (credentials: UserCredentials) => {
    await auth.post(auth_url + '/auth/signup', credentials);
  };

  const issueTokens = async (
    authCode: string,
    clientState: string,
    redirect_uri: string
  ) => {
    const response = await auth.post<TokenResponse>(
      auth_url + '/oauth/token',
      {
        grant_type: 'authorization_code',
        code: authCode,
        redirect_uri,
        client_id:
          process.env.NODE_ENV === 'production'
            ? 'steamscraper_client'
            : 'debug',
        code_verifier: clientState,
      },
      { withCredentials: true }
    );
    return response.data;
  };

  //   token_type will always be Bearer
  // expires_in is the time the token will live in seconds
  // access_token is a JWT signed token and is used to authenticate into the resource server
  // refresh_token is a JWT signed token and can be used in with the refresh grant
  // scope is a space delimited list of scopes the token has access to

  return { login, logout, resume, register, issueTokens };
};

// response_type must be set to code
// client_id is the client identifier you received when you first created the application
// redirect_uri indicates the URL to return the user to after authorization is complete, such as org.example.app://redirect
// state is a random string generated by your application, which you’ll verify later
// code_challenge must match the The code challenge as generated below,
// code_challenge_method – Either plain or S256, depending on whether the challenge is the plain verifier string or the SHA256 hash of the string. If this parameter is omitted, the server will assume plain.
